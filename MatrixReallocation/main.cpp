#include <cstdlib>
#include <fstream>

#include "reallocating.h"
#include "service.h"

#include "omp.h"

int main()
{
	setlocale(LC_ALL, "");
	ifstream file;
	file.open("../params.txt");
	// File needs to have a structure as follows (by a rows):
	// N1 - number of rows in matrix
	// N2 - number of columns in matrix
	// b1 - number of rows in block
	// b2 - number of columns in block
	int N1, N2, b1, b2;
	file >> N1 >> N2 >> b1 >> b2;
	file.close();

	cout << "N1 = " << N1 << endl;
	cout << "N2 = " << N2 << endl;
	cout << "b1 = " << b1 << endl;
	cout << "b2 = " << b2 << endl << endl;

	double* data = new double[N1*N2];	
	data = simple_fill(data, N1, N2);

	double* dt = get_reallocated(data, N1, N2, b1, b2);
	double time_ = omp_get_wtime();
	data = block_reallocate_matrix(data, N1, N2, b1, b2);
	time_ = omp_get_wtime() - time_;

	cout << "Результат:\n";
//	print_to(cout, data, N1, N2, 4);
	cout << "Эталон:\n";
//	print_to(cout, dt,   N1, N2, 4);
	cout << "Норма разности: ";
	cout << compare_arrays(dt, data, N1*N2) << endl << endl;
	cout << "Время работы: " << time_ << " секунд\n\n";

	/*
	 * Замечание! (ДЛЯ ВЕРСИИ N2 = koeff * b2, koeff - натуральное)
	 * Время работы алгоритма линейно зависит от числа строк в массиве и
	 * сильно (сложная зависимость) зависит от числа столбцов.
	 * Например:
	 * [ Процессор: Intel i5 3470, Ivy Bridge, 3.6 GHz, 4*32Kb(L1), 4*256Kb(L2), 6144Kb(L3) ]
	 * [ Параметры: N1 = 1000, b1 = b2 = 20 ]
	 * _______________
	 * N2	| t (сек.)
	 * ===============
	 * 1000	| 0.068
	 * 1100 | 0.2
	 * 1200 | 0.356
	 * 1300 | 0.643
	 * 1400 | 1.111
	 * 1500 | 1.272
	 * 1600 | 0.172
	 * 1700 | 0.563
	 * 1800 | 0.551
	 * 1900 | 0.466
	 * 2000 | 2.256
	 * 2100 | 2.485
	 * 2200 | 0.647
	 * 2300 | 0.304
	 * 2400 | 3.242
	 * 2500 | 0.498
	 * ============
	 * Это связано с тем, что при увеличении длины полосы,
	 * образованной стоящими рядом по горизонтали блоками
	 * увеличивается число и длины т.н. циклов, 
	 * т.е. последовательностией присваиваний элементов массива,
	 * образованных по правилу: A[ind(k+1)] = A[ind(k)], где ind(k+1) = f_ind(ind(k)),
	 * где f_ind(i) - отображение, сопоставляющее индексу элемента в старом размещении
	 * индекс в новом (блочном) размещении.
	 * Однако, при достижении длины полосы определенных значений
	 * число циклов резко сокращается, и процесс роста их количества начинается заново.
	 * Таким образом, зависимость времени работы алгоритма от числа столбцов
	 * есть, в действительности, зависимость от числа циклов в полосе.
	 * Она порождена особенностью алгоритма - при переходе от одного цикла к другому
	 * в условиях ограниченности дополнительной памяти для очередного индекса i,
	 * с которого предполагается начать обход следующего цикла,
	 * производится перебор индексов по правилу i = f_ind(i)
	 * и их поэлементное сравнение с системой различных представителей циклов,
	 * пока f_ind(i) не примет начального значения i, что укажет на то,
	 * что индекс i не расположен ни в одном из пройденных циклов.
	 * Производить это требуется потому, что природа циклов (в т.ч. их взаимное расположение) слишком сложна, 
	 * чтобы определить для общего случая место перехода от одного цикла к другому за 1 шаг.
 	*/
	delete[] data;
	delete[] dt;

//	system("pause");
}