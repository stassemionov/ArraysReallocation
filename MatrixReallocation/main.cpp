#include "reallocation.h"
#include "service.h"
#include "multiplication.h"
#include "testing.h"

#include <fstream>
#include <ctime>

#include "qralg.h"

using std::ifstream;

// Сделать!
//  1) Сократить просмотр больших промежутков при поиске нового цикла                    (СЛОЖНО)
//  2) Определить более надежное условие параллельности циклов (да и это не подводит..)  (СРЕДНЕ)
//  3) Найти способ не заносить элементы параллельных циклов в help_vec                  (СРЕДНЕ)
//  4) Подумать и поэкспериментировать, можно ли,
//     имея sdr для [b1,b2,d1,d2] и для [b2,b3,d2,d3], получить sdr для [b1,b3,d1,d3] ?  (СЛОЖНО)
//  5) Применить экономичные структуры данных для оптимизации объема памяти
//     для хранения посещенных элементов                                                 (ПРОСТО)
//  6) Исправить ошибки в release-версиях функций переразмещения
//     (инициализация некоторых полей структур нулями)                                   (ПРОСТО)
//  7) Проход по циклу сделать с двух сторон (?)                                         (ПРОСТО)
//  8) Добавить тест для копирования куска матрицы                                       (ПРОСТО)
//  9) Модифицировать способ определения нового цикла                                    (ПРОСТО)
// 10) Разобраться с обратным переразмещением матрицы-генератора при умножении матриц    (СРЕДНЕ)
// 11) Отрегулировать размер доп. вектора                                                (ПРОСТО)

// 12) Исправить QR-алгоритм с тайлингом (некоторые циклы не блочные!)                   (СРЕДНЕ)
// 13) Добавить в QR-алгоритм с тайлингом поддержку смещения начала отсчета блоков
//     когда ширина блока кратно больше его высоты                                       (СРЕДНЕ)

// 14) Переписать комментарии в соответствии с последними правками                       (ПРОСТО)
// 15) Сделать алгоритм двойного блочного переразмещения с использованием
//     соответствующей индексной функции, а не через композицию двух блочных
//     переразмещений, сравнить производительность и оставить лучший                     (СЛОЖНО)
// 16) Использовать делегат для выбора нужной индексной функции (?)                      (СРЕДНЕ)
// 17) Довести все тестируемые алгоритмы до равной степени оптимизации                   (ПРОСТО)
// 18) Переименовать функцию cycle_distribution_learning и некоторые другие              (ПРОСТО)
// 19) В разделе тестирования одинаковый код вынести в отдельные функции                 (ПРОСТО)
// 20) Пересчитать сложность основного алгоритма переразмещения                          (ПРОСТО)

int main()
{
    setlocale(LC_ALL, "");

 //   const TaskClass& floyd_params   = *read_floyd_algorythm_parameters();
    const TaskClass& qr_params      = *read_qr_parameters();
 //   const TaskClass* mult_params    = read_multiplication_parameters();
 //   const TaskClass& realloc_params = *read_reallocation_test_parameters();

 //   floyd_test(floyd_params, true);
    qralg_test(qr_params, true);
 //   matrix_multiplication_tests(mult_params[0], mult_params[1], true);
 //   reallocation_test(realloc_params, true);
}